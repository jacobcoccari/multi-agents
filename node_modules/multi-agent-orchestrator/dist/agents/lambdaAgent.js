"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaAgent = void 0;
const types_1 = require("../types");
const agent_1 = require("./agent");
const client_lambda_1 = require("@aws-sdk/client-lambda");
class LambdaAgent extends agent_1.Agent {
    constructor(options) {
        super(options);
        this.options = options;
        this.lambdaClient = new client_lambda_1.LambdaClient({ region: this.options.functionRegion });
    }
    defaultInputPayloadEncoder(inputText, chatHistory, userId, sessionId, additionalParams) {
        return JSON.stringify({
            query: inputText,
            chatHistory: chatHistory,
            additionalParams: additionalParams,
            userId: userId,
            sessionId: sessionId,
        });
    }
    defaultOutputPayloaderDecoder(response) {
        const decodedResponse = JSON.parse(JSON.parse(new TextDecoder("utf-8").decode(response.Payload)).body).response;
        const message = {
            role: types_1.ParticipantRole.ASSISTANT,
            content: [{ text: `${decodedResponse}` }]
        };
        return message;
    }
    async processRequest(inputText, userId, sessionId, chatHistory, additionalParams) {
        const payload = this.options.inputPayloadEncoder ? this.options.inputPayloadEncoder(inputText, chatHistory, userId, sessionId, additionalParams) : this.defaultInputPayloadEncoder(inputText, chatHistory, userId, sessionId, additionalParams);
        const invokeParams = {
            FunctionName: this.options.functionName,
            Payload: payload,
        };
        const response = await this.lambdaClient.send(new client_lambda_1.InvokeCommand(invokeParams));
        return new Promise((resolve) => {
            const message = this.options.outputPayloadDecoder ? this.options.outputPayloadDecoder(response) : this.defaultOutputPayloaderDecoder(response);
            resolve(message);
        });
    }
}
exports.LambdaAgent = LambdaAgent;
//# sourceMappingURL=lambdaAgent.js.map