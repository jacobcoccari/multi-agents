"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BedrockClassifier = void 0;
const types_1 = require("../types");
const client_bedrock_runtime_1 = require("@aws-sdk/client-bedrock-runtime");
const classifier_1 = require("./classifier");
const helpers_1 = require("../utils/helpers");
const logger_1 = require("../utils/logger");
/**
 * IntentClassifier class extends BedrockAgent to provide specialized functionality
 * for classifying user intents, selecting appropriate agents, and generating
 * structured response.
 */
class BedrockClassifier extends classifier_1.Classifier {
    /**
     * Constructs a new IntentClassifier instance.
     * @param options - Configuration options for the agent, inherited from AgentOptions.
     */
    constructor(options = {}) {
        var _a, _b, _c, _d;
        super();
        this.tools = [
            {
                toolSpec: {
                    name: "analyzePrompt",
                    description: "Analyze the user input and provide structured output",
                    inputSchema: {
                        json: {
                            type: "object",
                            properties: {
                                userinput: {
                                    type: "string",
                                    description: "The original user input",
                                },
                                selected_agent: {
                                    type: "string",
                                    description: "The name of the selected agent",
                                },
                                confidence: {
                                    type: "number",
                                    description: "Confidence level between 0 and 1",
                                },
                            },
                            required: ["userinput", "selected_agent", "confidence"],
                        },
                    },
                },
            },
        ];
        // Initialize default values or use provided options
        this.region = options.region || process.env.REGION;
        this.client = new client_bedrock_runtime_1.BedrockRuntimeClient({ region: this.region });
        this.modelId = options.modelId || types_1.BEDROCK_MODEL_ID_CLAUDE_3_5_SONNET;
        // Initialize inferenceConfig only if it's provided in options
        this.inferenceConfig = {
            maxTokens: (_a = options.inferenceConfig) === null || _a === void 0 ? void 0 : _a.maxTokens,
            temperature: (_b = options.inferenceConfig) === null || _b === void 0 ? void 0 : _b.temperature,
            topP: (_c = options.inferenceConfig) === null || _c === void 0 ? void 0 : _c.topP,
            stopSequences: (_d = options.inferenceConfig) === null || _d === void 0 ? void 0 : _d.stopSequences,
        };
    }
    /**
     * Method to process a request.
     * This method must be implemented by all concrete agent classes.
     *
     * @param inputText - The user input as a string.
     * @param chatHistory - An array of Message objects representing the conversation history.
     * @param additionalParams - Optional additional parameters as key-value pairs.
     * @returns A Promise that resolves to a Message object containing the agent's response.
     */
    /* eslint-disable @typescript-eslint/no-unused-vars */
    async processRequest(inputText, chatHistory) {
        // Construct the user's message based on the provided inputText
        const userMessage = {
            role: types_1.ParticipantRole.USER,
            content: [{ text: inputText }],
        };
        // Prepare the command to converse with the Bedrock API
        const converseCmd = {
            modelId: this.modelId,
            messages: [userMessage],
            system: [{ text: this.systemPrompt }],
            toolConfig: {
                tools: this.tools,
                toolChoice: {
                    tool: {
                        name: "analyzePrompt",
                    },
                },
            },
            inferenceConfiguration: {
                maximumTokens: this.inferenceConfig.maxTokens,
                temperature: this.inferenceConfig.temperature,
                topP: this.inferenceConfig.topP,
                stopSequences: this.inferenceConfig.stopSequences,
            },
        };
        try {
            const command = new client_bedrock_runtime_1.ConverseCommand(converseCmd);
            const response = await this.client.send(command);
            if (!response.output) {
                throw new Error("No output received from Bedrock model");
            }
            if (response.output.message.content) {
                const responseContentBlocks = response.output.message
                    .content;
                for (const contentBlock of responseContentBlocks) {
                    if ("toolUse" in contentBlock) {
                        const toolUse = contentBlock.toolUse;
                        if (!toolUse) {
                            throw new Error("No tool use found in the response");
                        }
                        if (!(0, helpers_1.isClassifierToolInput)(toolUse.input)) {
                            throw new Error("Tool input does not match expected structure");
                        }
                        const intentClassifierResult = {
                            selectedAgent: this.getAgentById(toolUse.input.selected_agent),
                            confidence: parseFloat(toolUse.input.confidence),
                        };
                        return intentClassifierResult;
                    }
                }
            }
            throw new Error("No valid tool use found in the response");
        }
        catch (error) {
            logger_1.Logger.logger.error("Error processing request:", error);
            // Instead of returning a default result, we'll throw the error
            throw error;
        }
    }
}
exports.BedrockClassifier = BedrockClassifier;
//# sourceMappingURL=bedrockClassifier.js.map