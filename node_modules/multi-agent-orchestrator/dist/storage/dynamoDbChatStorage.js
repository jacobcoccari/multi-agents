"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamoDbChatStorage = void 0;
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const chatStorage_1 = require("./chatStorage");
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
class DynamoDbChatStorage extends chatStorage_1.ChatStorage {
    constructor(tableName, region, ttlKey, ttlDuration) {
        super();
        this.ttlKey = null;
        this.ttlDuration = 3600;
        this.tableName = tableName;
        this.ttlKey = ttlKey || null;
        this.ttlDuration = Number(ttlDuration) || 3600;
        const client = new client_dynamodb_1.DynamoDBClient({ region });
        this.docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(client);
    }
    async saveChatMessage(userId, sessionId, agentId, newMessage, maxHistorySize) {
        const key = this.generateKey(userId, sessionId, agentId);
        // Fetch existing conversation
        const existingConversation = await this.fetchChat(userId, sessionId, agentId);
        if (super.isConsecutiveMessage(existingConversation, newMessage)) {
            logger_1.Logger.logger.log(`> Consecutive ${newMessage.role} message detected for agent ${agentId}. Not saving.`);
            return existingConversation;
        }
        // Add new message with timestamp
        const updatedConversation = [
            ...existingConversation.map(msg => ({ ...msg, timestamp: Date.now() })),
            { ...newMessage, timestamp: Date.now() }
        ];
        // Apply maxHistorySize limit if specified
        const trimmedConversation = super.trimConversation(updatedConversation, maxHistorySize);
        // Prepare item for DynamoDB
        const item = {
            PK: userId,
            SK: key,
            conversation: trimmedConversation,
        };
        if (this.ttlKey) {
            item[this.ttlKey] = Math.floor(Date.now() / 1000) + this.ttlDuration;
        }
        // Save to DynamoDB
        try {
            await this.docClient.send(new lib_dynamodb_1.PutCommand({
                TableName: this.tableName,
                Item: item,
            }));
        }
        catch (error) {
            logger_1.Logger.logger.error("Error saving conversation to DynamoDB:", error);
            throw error;
        }
        // Return the updated conversation without timestamps
        return trimmedConversation;
    }
    async fetchChat(userId, sessionId, agentId) {
        var _a;
        const key = this.generateKey(userId, sessionId, agentId);
        try {
            const response = await this.docClient.send(new lib_dynamodb_1.GetCommand({
                TableName: this.tableName,
                Key: { PK: userId, SK: key },
            }));
            const storedMessages = ((_a = response.Item) === null || _a === void 0 ? void 0 : _a.conversation) || [];
            return this.removeTimestamps(storedMessages);
        }
        catch (error) {
            logger_1.Logger.logger.error("Error getting conversation from DynamoDB:", error);
            throw error;
        }
    }
    async fetchAllChats(userId, sessionId) {
        try {
            const response = await this.docClient.send(new lib_dynamodb_1.QueryCommand({
                TableName: this.tableName,
                KeyConditionExpression: "PK = :pk and begins_with(SK, :skPrefix)",
                ExpressionAttributeValues: {
                    ":pk": userId,
                    ":skPrefix": `${sessionId}#`,
                },
            }));
            if (!response.Items || response.Items.length === 0) {
                return [];
            }
            const allChats = response.Items.flatMap(item => {
                if (!Array.isArray(item.conversation)) {
                    logger_1.Logger.logger.error("Unexpected item structure:", item);
                    return [];
                }
                // Extract agentId from the SK
                const agentId = item.SK.split('#')[1];
                return item.conversation.map(msg => {
                    var _a;
                    return ({
                        role: msg.role,
                        content: msg.role === types_1.ParticipantRole.ASSISTANT
                            ? [{ text: `[${agentId}] ${Array.isArray(msg.content) ? ((_a = msg.content[0]) === null || _a === void 0 ? void 0 : _a.text) || '' : msg.content || ''}` }]
                            : (Array.isArray(msg.content) ? msg.content.map(content => ({ text: content.text })) : [{ text: msg.content || '' }]),
                        timestamp: Number(msg.timestamp)
                    });
                });
            });
            allChats.sort((a, b) => a.timestamp - b.timestamp);
            return this.removeTimestamps(allChats);
        }
        catch (error) {
            logger_1.Logger.logger.error("Error querying conversations from DynamoDB:", error);
            throw error;
        }
    }
    generateKey(userId, sessionId, agentId) {
        return `${sessionId}#${agentId}`;
    }
    removeTimestamps(messages) {
        return messages.map(msg => {
            const { timestamp: _timestamp, ...rest } = msg;
            return rest;
        });
    }
}
exports.DynamoDbChatStorage = DynamoDbChatStorage;
//# sourceMappingURL=dynamoDbChatStorage.js.map