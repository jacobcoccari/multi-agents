import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, isSerializableHeaderValue, limitedParseDouble as __limitedParseDouble, map, take, withBaseException, } from "@smithy/smithy-client";
import { LexRuntimeV2ServiceException as __BaseException } from "../models/LexRuntimeV2ServiceException";
import { AccessDeniedException, BadGatewayException, ConflictException, DependencyFailedException, InternalServerException, ResourceNotFoundException, StartConversationRequestEventStream, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_DeleteSessionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_GetSessionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_PutSessionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_r]: input[_rCT],
    });
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        messages: (_) => _json(_),
        requestAttributes: (_) => _json(_),
        sessionState: (_) => se_SessionState(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RecognizeTextCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/text");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        requestAttributes: (_) => _json(_),
        sessionState: (_) => se_SessionState(_, context),
        text: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RecognizeUtteranceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        [_ct]: input[_rCTe] || "application/octet-stream",
        [_xalss]: input[_sS],
        [_xalra]: input[_rA],
        [_rct]: input[_rCT],
    });
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/utterance");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.inputStream !== undefined) {
        body = input.inputStream;
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartConversationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xalcm]: input[_cM],
    });
    b.bp("/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/conversation");
    b.p("botId", () => input.botId, "{botId}", false);
    b.p("botAliasId", () => input.botAliasId, "{botAliasId}", false);
    b.p("localeId", () => input.localeId, "{localeId}", false);
    b.p("sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.requestEventStream !== undefined) {
        body = se_StartConversationRequestEventStream(input.requestEventStream, context);
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_DeleteSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasId: __expectString,
        botId: __expectString,
        localeId: __expectString,
        sessionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_cT]: [, output.headers[_ct]],
        [_m]: [, output.headers[_xalm]],
        [_sS]: [, output.headers[_xalss]],
        [_rA]: [, output.headers[_xalra]],
        [_sI]: [, output.headers[_xalsi]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
export const de_RecognizeTextCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: _json,
        recognizedBotMember: _json,
        requestAttributes: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RecognizeUtteranceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_iM]: [, output.headers[_xalim]],
        [_cT]: [, output.headers[_ct]],
        [_m]: [, output.headers[_xalm]],
        [_i]: [, output.headers[_xali]],
        [_sS]: [, output.headers[_xalss]],
        [_rA]: [, output.headers[_xalra]],
        [_sI]: [, output.headers[_xalsi]],
        [_iT]: [, output.headers[_xalit]],
        [_rBM]: [, output.headers[_xalrbm]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
export const de_StartConversationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = output.body;
    contents.responseEventStream = de_StartConversationResponseEventStream(data, context);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadGatewayExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadGatewayException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DependencyFailedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DependencyFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_StartConversationRequestEventStream = (input, context) => {
    const eventMarshallingVisitor = (event) => StartConversationRequestEventStream.visit(event, {
        ConfigurationEvent: (value) => se_ConfigurationEvent_event(value, context),
        AudioInputEvent: (value) => se_AudioInputEvent_event(value, context),
        DTMFInputEvent: (value) => se_DTMFInputEvent_event(value, context),
        TextInputEvent: (value) => se_TextInputEvent_event(value, context),
        PlaybackCompletionEvent: (value) => se_PlaybackCompletionEvent_event(value, context),
        DisconnectionEvent: (value) => se_DisconnectionEvent_event(value, context),
        _: (value) => value,
    });
    return context.eventStreamMarshaller.serialize(input, eventMarshallingVisitor);
};
const se_AudioInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "AudioInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_AudioInputEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_ConfigurationEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "ConfigurationEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_ConfigurationEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DisconnectionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DisconnectionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DTMFInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DTMFInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_PlaybackCompletionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "PlaybackCompletionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_TextInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "TextInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const de_StartConversationResponseEventStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["PlaybackInterruptionEvent"] != null) {
            return {
                PlaybackInterruptionEvent: await de_PlaybackInterruptionEvent_event(event["PlaybackInterruptionEvent"], context),
            };
        }
        if (event["TranscriptEvent"] != null) {
            return {
                TranscriptEvent: await de_TranscriptEvent_event(event["TranscriptEvent"], context),
            };
        }
        if (event["IntentResultEvent"] != null) {
            return {
                IntentResultEvent: await de_IntentResultEvent_event(event["IntentResultEvent"], context),
            };
        }
        if (event["TextResponseEvent"] != null) {
            return {
                TextResponseEvent: await de_TextResponseEvent_event(event["TextResponseEvent"], context),
            };
        }
        if (event["AudioResponseEvent"] != null) {
            return {
                AudioResponseEvent: await de_AudioResponseEvent_event(event["AudioResponseEvent"], context),
            };
        }
        if (event["HeartbeatEvent"] != null) {
            return {
                HeartbeatEvent: await de_HeartbeatEvent_event(event["HeartbeatEvent"], context),
            };
        }
        if (event["AccessDeniedException"] != null) {
            return {
                AccessDeniedException: await de_AccessDeniedException_event(event["AccessDeniedException"], context),
            };
        }
        if (event["ResourceNotFoundException"] != null) {
            return {
                ResourceNotFoundException: await de_ResourceNotFoundException_event(event["ResourceNotFoundException"], context),
            };
        }
        if (event["ValidationException"] != null) {
            return {
                ValidationException: await de_ValidationException_event(event["ValidationException"], context),
            };
        }
        if (event["ThrottlingException"] != null) {
            return {
                ThrottlingException: await de_ThrottlingException_event(event["ThrottlingException"], context),
            };
        }
        if (event["InternalServerException"] != null) {
            return {
                InternalServerException: await de_InternalServerException_event(event["InternalServerException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["DependencyFailedException"] != null) {
            return {
                DependencyFailedException: await de_DependencyFailedException_event(event["DependencyFailedException"], context),
            };
        }
        if (event["BadGatewayException"] != null) {
            return {
                BadGatewayException: await de_BadGatewayException_event(event["BadGatewayException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_AccessDeniedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_AccessDeniedExceptionRes(parsedOutput, context);
};
const de_AudioResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_AudioResponseEvent(data, context));
    return contents;
};
const de_BadGatewayException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_BadGatewayExceptionRes(parsedOutput, context);
};
const de_ConflictException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ConflictExceptionRes(parsedOutput, context);
};
const de_DependencyFailedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_DependencyFailedExceptionRes(parsedOutput, context);
};
const de_HeartbeatEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_IntentResultEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_IntentResultEvent(data, context));
    return contents;
};
const de_InternalServerException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_InternalServerExceptionRes(parsedOutput, context);
};
const de_PlaybackInterruptionEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ResourceNotFoundException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ResourceNotFoundExceptionRes(parsedOutput, context);
};
const de_TextResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ThrottlingException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ThrottlingExceptionRes(parsedOutput, context);
};
const de_TranscriptEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ValidationException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ValidationExceptionRes(parsedOutput, context);
};
const se_AudioInputEvent = (input, context) => {
    return take(input, {
        audioChunk: context.base64Encoder,
        clientTimestampMillis: [],
        contentType: [],
        eventId: [],
    });
};
const se_ConfigurationEvent = (input, context) => {
    return take(input, {
        clientTimestampMillis: [],
        disablePlayback: [],
        eventId: [],
        requestAttributes: _json,
        responseContentType: [],
        sessionState: (_) => se_SessionState(_, context),
        welcomeMessages: _json,
    });
};
const se_DialogAction = (input, context) => {
    return take(input, {
        slotElicitationStyle: [],
        slotToElicit: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
        type: [],
    });
};
const se_ElicitSubSlot = (input, context) => {
    return take(input, {
        name: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
    });
};
const se_Intent = (input, context) => {
    return take(input, {
        confirmationState: [],
        name: [],
        slots: (_) => se_Slots(_, context),
        state: [],
    });
};
const se_RuntimeHintDetails = (input, context) => {
    return take(input, {
        runtimeHintValues: _json,
        subSlotHints: (_) => se_SlotHintsSlotMap(_, context),
    });
};
const se_RuntimeHints = (input, context) => {
    return take(input, {
        slotHints: (_) => se_SlotHintsIntentMap(_, context),
    });
};
const se_SessionState = (input, context) => {
    return take(input, {
        activeContexts: _json,
        dialogAction: (_) => se_DialogAction(_, context),
        intent: (_) => se_Intent(_, context),
        originatingRequestId: [],
        runtimeHints: (_) => se_RuntimeHints(_, context),
        sessionAttributes: _json,
    });
};
const se_Slot = (input, context) => {
    return take(input, {
        shape: [],
        subSlots: (_) => se_Slots(_, context),
        value: _json,
        values: (_) => se_Values(_, context),
    });
};
const se_SlotHintsIntentMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const se_SlotHintsSlotMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const se_Slots = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Slot(value, context);
        return acc;
    }, {});
};
const se_Values = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Slot(entry, context);
    });
};
const de_AudioResponseEvent = (output, context) => {
    return take(output, {
        audioChunk: context.base64Decoder,
        contentType: __expectString,
        eventId: __expectString,
    });
};
const de_ConfidenceScore = (output, context) => {
    return take(output, {
        score: __limitedParseDouble,
    });
};
const de_DialogAction = (output, context) => {
    return take(output, {
        slotElicitationStyle: __expectString,
        slotToElicit: __expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
        type: __expectString,
    });
};
const de_ElicitSubSlot = (output, context) => {
    return take(output, {
        name: __expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
    });
};
const de_Intent = (output, context) => {
    return take(output, {
        confirmationState: __expectString,
        name: __expectString,
        slots: (_) => de_Slots(_, context),
        state: __expectString,
    });
};
const de_IntentResultEvent = (output, context) => {
    return take(output, {
        eventId: __expectString,
        inputMode: __expectString,
        interpretations: (_) => de_Interpretations(_, context),
        recognizedBotMember: _json,
        requestAttributes: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
};
const de_Interpretation = (output, context) => {
    return take(output, {
        intent: (_) => de_Intent(_, context),
        interpretationSource: __expectString,
        nluConfidence: (_) => de_ConfidenceScore(_, context),
        sentimentResponse: (_) => de_SentimentResponse(_, context),
    });
};
const de_Interpretations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Interpretation(entry, context);
    });
    return retVal;
};
const de_RuntimeHintDetails = (output, context) => {
    return take(output, {
        runtimeHintValues: _json,
        subSlotHints: (_) => de_SlotHintsSlotMap(_, context),
    });
};
const de_RuntimeHints = (output, context) => {
    return take(output, {
        slotHints: (_) => de_SlotHintsIntentMap(_, context),
    });
};
const de_SentimentResponse = (output, context) => {
    return take(output, {
        sentiment: __expectString,
        sentimentScore: (_) => de_SentimentScore(_, context),
    });
};
const de_SentimentScore = (output, context) => {
    return take(output, {
        mixed: __limitedParseDouble,
        negative: __limitedParseDouble,
        neutral: __limitedParseDouble,
        positive: __limitedParseDouble,
    });
};
const de_SessionState = (output, context) => {
    return take(output, {
        activeContexts: _json,
        dialogAction: (_) => de_DialogAction(_, context),
        intent: (_) => de_Intent(_, context),
        originatingRequestId: __expectString,
        runtimeHints: (_) => de_RuntimeHints(_, context),
        sessionAttributes: _json,
    });
};
const de_Slot = (output, context) => {
    return take(output, {
        shape: __expectString,
        subSlots: (_) => de_Slots(_, context),
        value: _json,
        values: (_) => de_Values(_, context),
    });
};
const de_SlotHintsIntentMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const de_SlotHintsSlotMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const de_Slots = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Slot(value, context);
        return acc;
    }, {});
};
const de_Values = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Slot(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const _cM = "conversationMode";
const _cT = "contentType";
const _ct = "content-type";
const _i = "interpretations";
const _iM = "inputMode";
const _iT = "inputTranscript";
const _m = "messages";
const _r = "responsecontenttype";
const _rA = "requestAttributes";
const _rBM = "recognizedBotMember";
const _rCT = "responseContentType";
const _rCTe = "requestContentType";
const _rct = "response-content-type";
const _sI = "sessionId";
const _sS = "sessionState";
const _xalcm = "x-amz-lex-conversation-mode";
const _xali = "x-amz-lex-interpretations";
const _xalim = "x-amz-lex-input-mode";
const _xalit = "x-amz-lex-input-transcript";
const _xalm = "x-amz-lex-messages";
const _xalra = "x-amz-lex-request-attributes";
const _xalrbm = "x-amz-lex-recognized-bot-member";
const _xalsi = "x-amz-lex-session-id";
const _xalss = "x-amz-lex-session-state";
